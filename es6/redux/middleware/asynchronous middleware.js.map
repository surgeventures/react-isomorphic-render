{"version":3,"sources":["../../../source/redux/middleware/asynchronous middleware.js"],"names":["exists","is_object","goto_action","location_url","asynchronous_middleware","http_client","asynchronous_action_event_naming","server","on_error","get_history","dispatch","getState","cancellable_promises","promise","action","event","events","cancelPrevious","rest","next","length","Error","Request","Success","Failure","type","promised","then","cancellable","cancel","has","get","set","result","delete","error","error_data","data","message","status","preloading","location","getCurrentLocation","path","pathname","url","redirect","to"],"mappings":"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","file":"asynchronous middleware.js","sourcesContent":["import { exists, is_object } from '../../helpers'\nimport { goto_action } from '../actions'\nimport { location_url } from '../../location'\n\n// Asynchronous middleware (e.g. for HTTP Ajax calls).\n//\n// Takes effect only if the `dispatch`ed action has \n// `promise` function and `events` (or `event`) property.\n//\n// `dispatch()` call will return a `Promise`.\n//\nexport default function asynchronous_middleware(http_client, asynchronous_action_event_naming, server, on_error, get_history)\n{\n\treturn ({ dispatch, getState }) =>\n\t{\n\t\t// Can cancel previous actions of the same `type` (if configured).\n\t\t// E.g. for an AJAX autocomplete.\n\t\tconst cancellable_promises = new Map()\n\n\t\treturn next => action =>\n\t\t{\n\t\t\tlet { promise, event, events, cancelPrevious, ...rest } = action\n\n\t\t\t// If the dispatched action doesn't have a `promise` function property then do nothing\n\t\t\tif (typeof promise !== 'function')\n\t\t\t{\n\t\t\t\treturn next(action)\n\t\t\t}\n\n\t\t\t// Generate the three event names automatically based on a base event name\n\t\t\tif (!events && typeof event === 'string')\n\t\t\t{\n\t\t\t\tevents = asynchronous_action_event_naming(event)\n\t\t\t}\n\n\t\t\t// Validate `events` property\n\t\t\tif (!events || events.length !== 3)\n\t\t\t{\n\t\t\t\tthrow new Error(`\"events\" property must be an array of 3 event names: e.g. ['pending', 'success', 'error']`)\n\t\t\t}\n\n\t\t\t// event names\n\t\t\tconst [Request, Success, Failure] = events\n\n\t\t\t// dispatch the `pending` event to the Redux store\n\t\t\tdispatch({ ...rest, type: Request })\n\n\t\t\t// Run the asychronous action (e.g. an HTTP request)\n\t\t\tconst promised = promise(http_client)\n\n\t\t\t// Validate that `promise()` actually returned a `Promise`\n\t\t\tif (!promised || typeof promised.then !== 'function')\n\t\t\t{\n\t\t\t\tthrow new Error(`\"promise\" function must return a Promise. Got:`, promised)\n\t\t\t}\n\n\t\t\t// Is the action promise cancellable\n\t\t\tconst cancellable = !server && cancelPrevious && typeof promised.cancel === 'function'\n\n\t\t\t// Cancel previous action of the same `type` (if configured).\n\t\t\t// E.g. for an AJAX autocomplete.\n\t\t\tif (cancellable)\n\t\t\t{\n\t\t\t\tif (cancellable_promises.has(Request))\n\t\t\t\t{\n\t\t\t\t\tcancellable_promises.get(Request).cancel()\n\t\t\t\t}\n\n\t\t\t\tcancellable_promises.set(Request, promised)\n\t\t\t}\n\n\t\t\treturn promised.then\n\t\t\t(\n\t\t\t\t// If the Promise resolved\n\t\t\t\t// (e.g. an HTTP request succeeded)\n\t\t\t\t(result) =>\n\t\t\t\t{\n\t\t\t\t\t// The default `Promise` implementation has no `.finally()`\n\t\t\t\t\tif (cancellable)\n\t\t\t\t\t{\n\t\t\t\t\t\tcancellable_promises.delete(Request)\n\t\t\t\t\t}\n\n\t\t\t\t\t// Dispatch the `success` event to the Redux store\n\t\t\t\t\tdispatch\n\t\t\t\t\t({\n\t\t\t\t\t\t...rest,\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\ttype : Success\n\t\t\t\t\t})\n\n\t\t\t\t\t// The Promise returned from `dispatch()` call\n\t\t\t\t\t// is resolved with the `promise` resolved value.\n\t\t\t\t\treturn result\n\t\t\t\t},\n\t\t\t\t// if the Http request failed\n\t\t\t\t//\n\t\t\t\t// (Http status !== 20x\n\t\t\t\t//  or the Http response JSON object has an `error` field)\n\t\t\t\t(error) =>\n\t\t\t\t{\n\t\t\t\t\t// The default `Promise` implementation has no `.finally()`\n\t\t\t\t\tif (cancellable)\n\t\t\t\t\t{\n\t\t\t\t\t\tcancellable_promises.delete(Request)\n\t\t\t\t\t}\n\n\t\t\t\t\t// Transform Javascript `Error` instance into a plain JSON object\n\t\t\t\t\t// because the meaning of the `error` action is different\n\t\t\t\t\t// from what `Error` class is: it should only carry info like\n\t\t\t\t\t// `status`, `message` and possible other values (e.g. `code`),\n\t\t\t\t\t// without any stack traces, line numbers, etc.\n\t\t\t\t\t// I.e. the `error` action should be a plain javascript object,\n\t\t\t\t\t// not an instance of an `Error` class, because it's Redux (stateless).\n\n\t\t\t\t\t// `error` is an `Error` instance thrown by `http client.js`.\n\t\t\t\t\t// It has `.data` JSON object set to HTTP response data\n\t\t\t\t\t// in case of an `application/json` response.\n\t\t\t\t\tconst error_data = is_object(error.data) ? error.data : {}\n\n\t\t\t\t\tif (!exists(error_data.message))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_data.message = error.message\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!exists(error_data.status))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_data.status = error.status\n\t\t\t\t\t}\n\n\t\t\t\t\t// Dispatch the `failure` event to the Redux store\n\t\t\t\t\tdispatch\n\t\t\t\t\t({\n\t\t\t\t\t\t...rest,\n\t\t\t\t\t\terror : error_data,\n\t\t\t\t\t\ttype  : Failure\n\t\t\t\t\t})\n\n\t\t\t\t\t// The Promise returned from `dispatch()` call\n\t\t\t\t\t// is rejected with this error.\n\n\t\t\t\t\t// if (error.data)\n\t\t\t\t\t// {\n\t\t\t\t\t// \tdelete error.data\n\t\t\t\t\t// }\n\t\t\t\t\t//\n\t\t\t\t\t// for (let key of Object.keys(error_data))\n\t\t\t\t\t// {\n\t\t\t\t\t// \terror[key] = error_data[key]\n\t\t\t\t\t// }\n\n\t\t\t\t\t// Only checks `http` calls which are not part of `@preload()`\n\t\t\t\t\t// so that they don't get \"error handled\" twice\n\t\t\t\t\t// (doesn't affect anything, just a minor optimization).\n\t\t\t\t\t// Also only checks `http` calls on client side\n\t\t\t\t\t// because on server side `http` calls can be\n\t\t\t\t\t// either part of `@preload` of part of `initialize`\n\t\t\t\t\t// which are already \"error handled\".\n\t\t\t\t\t// On the client side though, an `http` call\n\t\t\t\t\t// may be performed via some user input,\n\t\t\t\t\t// so it needs this separate case \"error handler\".\n\t\t\t\t\tif (!server && on_error && !action.preloading)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst location = get_history().getCurrentLocation()\n\n\t\t\t\t\t\t// Report the error\n\t\t\t\t\t\t// (for example, redirect to a login page\n\t\t\t\t\t\t//  if a JWT \"access token\" expired)\n\t\t\t\t\t\ton_error(error,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpath : location.pathname,\n\t\t\t\t\t\t\turl  : location_url(location),\n\t\t\t\t\t\t\t// Using `goto` instead of `redirect` here\n\t\t\t\t\t\t\t// because it's not part of `@preload()`\n\t\t\t\t\t\t\t// and is therefore part of some kind of an HTTP request\n\t\t\t\t\t\t\t// triggered by user input (e.g. form submission)\n\t\t\t\t\t\t\t// which means it is convenient to be able to\n\t\t\t\t\t\t\t// go \"Back\" to the page on which the error originated.\n\t\t\t\t\t\t\tredirect : to => dispatch(goto_action(to)),\n\t\t\t\t\t\t\tdispatch,\n\t\t\t\t\t\t\tgetState,\n\t\t\t\t\t\t\tserver\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}\n}"]}