{"version":3,"sources":["../../source/react-router/match.js"],"names":["match_routes_against_location","routes","location","history","resolve","reject","error","redirect_location","router_state","redirect","Error","getCurrentLocation"],"mappings":";;;;;;;;;;kBAuBwBA,6B;;AAvBxB;;AAEA;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASA,6BAAT,OACf;AAAA,KADwDC,MACxD,QADwDA,MACxD;AAAA,KADgEC,QAChE,QADgEA,QAChE;AAAA,KAD0EC,OAC1E,QAD0EA,OAC1E;;AACC;AACA;AACA;AACA,QAAO,sBAAY,UAACC,OAAD,EAAUC,MAAV,EACnB;AACC;AACA,0BAAM,EAAEJ,cAAF,EAAUC,kBAAV,EAAoBC,gBAApB,EAAN,EAAqC,UAACG,KAAD,EAAQC,iBAAR,EAA2BC,YAA3B,EACrC;AACC;AACA,OAAIF,KAAJ,EACA;AACC,WAAOD,OAAOC,KAAP,CAAP;AACA;;AAED;AACA;AACA;AACA,OAAIC,iBAAJ,EACA;AACC,WAAOH,QACN;AACAK,eAAUF;AADV,KADM,CAAP;AAIA;;AAED;AACA,OAAI,CAACC,YAAL,EACA;AACC,WAAOH,OAAO,IAAIK,KAAJ,+BAAsC,4BAAaR,YAAYC,QAAQQ,kBAAR,EAAzB,CAAtC,OAAP,CAAP;AACA;;AAED,UAAOP,QAAQ,EAAEI,0BAAF,EAAR,CAAP;AACA,GA1BD;AA2BA,EA9BM,CAAP;AA+BA","file":"match.js","sourcesContent":["import { match } from 'react-router'\n\nimport { location_url } from '../location'\n\n// Matches a `location` (or a `url`) agains the `routes`\n// (to a hierarchy of React-router `<Route/>`s).\n//\n// If no `location` is passed but `history` was passed\n// then `location` is taken from the `history`'s current location.\n//\n// If no `history` is passed then an in-memory history is created.\n// (server side usage)\n//\n// Returns a Promise resolving to an object:\n//\n//   redirect    - in case of an HTTP redirect\n//\n//   router_state - the \"next Router state\":\n//\n//       components - matched hierarchy of React-router `<Route/>`s\n//       location   - ...\n//       params     - ...\n//\nexport default function match_routes_against_location({ routes, location, history })\n{\n\t// (not using `promisify()` helper here \n\t//  to avoid introducing dependency on `bluebird` Promise library)\n\t//\n\treturn new Promise((resolve, reject) =>\n\t{\n\t\t// Perform routing for this `location`\n\t\tmatch({ routes, location, history }, (error, redirect_location, router_state) =>\n\t\t{\n\t\t\t// If routing process failed\n\t\t\tif (error)\n\t\t\t{\n\t\t\t\treturn reject(error)\n\t\t\t}\n\n\t\t\t// If a decision to perform a redirect was made \n\t\t\t// during the routing process (e.g. `<Redirect/>`),\n\t\t\t// then redirect to another URL\n\t\t\tif (redirect_location)\n\t\t\t{\n\t\t\t\treturn resolve\n\t\t\t\t({\n\t\t\t\t\tredirect: redirect_location\n\t\t\t\t})\n\t\t\t}\n\n\t\t\t// In case some weird stuff happened\n\t\t\tif (!router_state)\n\t\t\t{\n\t\t\t\treturn reject(new Error(`No <Route/> matches URL \"${location_url(location || history.getCurrentLocation())}\"`))\n\t\t\t}\n\n\t\t\treturn resolve({ router_state })\n\t\t})\n\t})\n}"]}